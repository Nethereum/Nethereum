@using MudBlazor
@using System
@using System.Collections.Generic
@using System.Linq
@using Nethereum.RPC.Chain
@using Nethereum.Wallet.UI.Components.SendTransaction
@using Nethereum.Wallet.UI.Components.SendTransaction.Models
@using Nethereum.Wallet.UI.Components.Core.Localization
@using Nethereum.Wallet.UI.Components.Blazor.Shared
@using Nethereum.Wallet.UI.Components.Blazor.Contacts
@using Nethereum.Wallet.UI.Components.Blazor.Tokens
@using Nethereum.Wallet.Services.Contacts
@using Nethereum.Wallet.Services.Tokens.Models
@using Nethereum.Wallet.WalletAccounts
@using Nethereum.Wallet.Diagnostics
@using Nethereum.Wallet.UI.Components.Dashboard
@using static Nethereum.Wallet.UI.Components.SendTransaction.SendNativeTokenLocalizer
@inject SendNativeTokenViewModel ViewModel
@inject IComponentLocalizer<SendNativeTokenViewModel> Localizer
@inject IWalletLocalizationService LocalizationService
@inject IJSRuntime JSRuntime
@implements IDisposable
@implements INavigatablePlugin

@if (_currentSubView == TransferSubView.ChainPicker)
{
    <ChainPicker UserChains="@ViewModel.AvailableChains"
                 AllChains="@ViewModel.AvailableChains"
                 SelectedChainId="@((long?)ViewModel.SelectedChain?.ChainId)"
                 IsCompactMode="@IsCompactMode"
                 OnChainSelected="@HandleChainSelected"
                 OnExit="@(async () => await SetSubView(TransferSubView.None))" />
}
else if (_currentSubView == TransferSubView.TokenPicker)
{
    <TokenPicker UserTokens="@ViewModel.AvailableTokens"
                 AllTokens="@ViewModel.AllKnownTokens"
                 SelectedToken="@ViewModel.SelectedToken"
                 ChainId="@((long?)ViewModel.SelectedChain?.ChainId)"
                 IsCompactMode="@IsCompactMode"
                 IsSearching="@ViewModel.IsSearchingTokens"
                 OnTokenSelected="@HandleTokenSelected"
                 OnSearch="@HandleTokenSearch"
                 OnGetBalance="@HandleGetBalance"
                 LoadingBalanceTokens="@ViewModel.LoadingBalanceTokens"
                 OnAddCustomToken="@(async () => await SetSubView(TransferSubView.AddToken))"
                 OnExit="@(async () => await SetSubView(TransferSubView.None))" />
}
else if (_currentSubView == TransferSubView.ContactPicker)
{
    <ContactList IsSelectable="true"
                 IsCompactMode="@IsCompactMode"
                 ShowExit="true"
                 OnContactSelected="@HandleContactSelected"
                 OnExit="@(async () => await SetSubView(TransferSubView.None))" />
}
else if (_currentSubView == TransferSubView.AddToken)
{
    <AddCustomToken OnTokenAdded="@HandleTokenAdded" OnCancel="@(async () => await SetSubView(TransferSubView.TokenPicker))" />
}
else if (_currentSubView == TransferSubView.AccountPicker)
{
    <AccountPicker Accounts="@ViewModel.AvailableAccounts"
                   SelectedAccount="@ViewModel.SelectedAccount"
                   IsCompactMode="@IsCompactMode"
                   OnAccountSelected="@HandleAccountSelected"
                   OnExit="@(async () => await SetSubView(TransferSubView.None))" />
}
else
{
<WalletFormLayout
                  ShowHeader="false"
                  Title="@Localizer.GetString(Keys.Title)"
                  Subtitle=""
                  Steps="@formSteps"
                  CurrentStepIndex="@(ViewModel.CurrentStep - 1)"
                  ShowExit="@(ViewModel.CurrentStep > 1)"
                  ExitText="@(ViewModel.CurrentStep == 3 ? Localizer.GetString(Keys.Done) : Localizer.GetString(Keys.Cancel))"
                  BackText="@Localizer.GetString(Keys.Previous)"
                  ContinueText="@Localizer.GetString(Keys.ContinueButton)"
                  PrimaryText="@Localizer.GetString(Keys.ConfirmTransaction)"
                  StepLocalizer="@Localizer"
                  ShowBack="@(ViewModel.CanGoBack && ViewModel.CurrentStep != 3)"
                  ShowContinue="@(ViewModel.CurrentStep == 1)"
                  ShowPrimary="@(ViewModel.CurrentStep == 2)"
                  ContinueDisabled="@(!ViewModel.CanProceedToNextStep)"
                  PrimaryDisabled="@ViewModel.IsLoading"
                  IsCompactMode="@IsCompactMode"
                  OnExit="@HandleCancel"
                  OnBack="@HandleBack"
                  OnContinue="@HandleContinue"
                  OnPrimary="@HandleSendTransaction">

    <ActionButtons>
        @if (ViewModel.CurrentStep == 3 && ViewModel.Transaction.TransactionStatus != null && ViewModel.Transaction.TransactionStatus.HasExplorerUrl)
        {
            <WalletBarActionButton Icon="@Icons.Material.Filled.OpenInNew"
                                   Text="@Localizer.GetString(Keys.ViewTransactionButton)"
                                   OnClick="@(() => OpenExplorer(ViewModel.Transaction.TransactionStatus.ExplorerUrl))" />
        }
    </ActionButtons>
    <ChildContent>
        
        @if (ViewModel.IsLoading)
        {
            <WalletContentSection Class="spacing-normal">
                <div class="loading-state">
                    <MudProgressCircular Color="Color.Primary" Size="Size.Large" Indeterminate="true" />
                    <MudText Typo="Typo.body2" Class="mt-3" Color="Color.Secondary">
                        @(ViewModel.CurrentStep == 2 ? 
                          Localizer.GetString(Keys.LoadingTransaction) : 
                          Localizer.GetString(Keys.PreparingTransaction))
                    </MudText>
                </div>
            </WalletContentSection>
        }
        else
        {
            @switch (ViewModel.CurrentStep)
            {
                case 1:
                    <TokenTransferInput ViewModel="ViewModel"
                                       OnShowChainPicker="@(async () => await SetSubView(TransferSubView.ChainPicker))"
                                       OnShowTokenPicker="@(async () => await SetSubView(TransferSubView.TokenPicker))"
                                       OnShowContactPicker="@(async () => await SetSubView(TransferSubView.ContactPicker))"
                                       OnShowAccountPicker="@(async () => await SetSubView(TransferSubView.AccountPicker))"
                                       OnAddToken="@(async () => await SetSubView(TransferSubView.AddToken))"
                                       IsCompactMode="@IsCompactMode" />
                    break;
                    
                case 2:
                    <TransactionInput ViewModel="ViewModel.Transaction" 
                                     Layout="TransactionInputLayout.Confirmation"
                                     ShowTransactionDetails="true"
                                     ShowGasConfiguration="true"
                                     ShowAdvancedOptions="true"
                                     ShowDataDecoding="true"
                                     ShowCostSummary="true"
                                     RecipientReadOnly="true"
                                     AmountReadOnly="true"
                                     AllowGasModeSwitch="true" />
                    break;
                    
                case 3:
                    @if (ViewModel.Transaction.TransactionStatus != null)
                    {
                        <TransactionStatus ViewModel="@ViewModel.Transaction.TransactionStatus" 
                                          IsCompactMode="@IsCompactMode"
                                          />
                    }
                    else
                    {
                        <!-- Fallback if status not initialized (shouldn't happen) -->
                        <WalletFormSection>
                            <MudAlert Severity="Severity.Error">Transaction status not available</MudAlert>
                        </WalletFormSection>
                    }
                    break;
            }
        }
        
        @if (!string.IsNullOrEmpty(ViewModel.ErrorMessage))
        {
            <WalletContentSection Class="spacing-normal">
                <WalletInfoCard Severity="WalletInfoCard.WalletInfoSeverity.Error"
                                Title="@Localizer.GetString(Keys.TransactionFailed)"
                                Description="@ViewModel.ErrorMessage"
                                Icon="@Icons.Material.Filled.Error" />
            </WalletContentSection>
        }
    </ChildContent>
</WalletFormLayout>
}

@code {
    [Parameter] public EventCallback OnTransactionSent { get; set; }
    [Parameter] public EventCallback OnCancel { get; set; }

    [Parameter] public string? FromAddress { get; set; }
    [Parameter] public string TokenSymbol { get; set; } = "ETH";
    [Parameter] public int TokenDecimals { get; set; } = 18;
    [Parameter] public bool IsCompactMode { get; set; } = false;
    [Parameter] public string? PreSelectedContractAddress { get; set; }
    [Parameter] public long? PreSelectedChainId { get; set; }
    [Parameter] public Action<object>? OnReady { get; set; }

    private enum TransferSubView { None, ChainPicker, TokenPicker, ContactPicker, AddToken, AccountPicker }
    private TransferSubView _currentSubView = TransferSubView.None;
    private List<WalletFormStep> formSteps = new();
    
    protected override async Task OnInitializedAsync()
    {
        Trace("TokenTransfer OnInitializedAsync start");
        // Subscribe to language changes
        LocalizationService.LanguageChanged += OnLanguageChanged;
        
        // Subscribe to NativeTransfer property changes to update UI
        if (ViewModel?.NativeTransfer != null)
        {
            ViewModel.NativeTransfer.PropertyChanged += OnTransferModelPropertyChanged;
        }
        
        // Set up step names with localization keys
        formSteps = new List<WalletFormStep>
        {
            new WalletFormStep { 
                LocalizationKey = SendNativeTokenLocalizer.Keys.Step1Title,
                LocalizationComponentType = typeof(SendNativeTokenViewModel),
                Label = "Transaction Details" // Fallback
            },
            new WalletFormStep { 
                LocalizationKey = SendNativeTokenLocalizer.Keys.Step2Title,
                LocalizationComponentType = typeof(SendNativeTokenViewModel),
                Label = "Confirm Transaction" // Fallback
            },
            new WalletFormStep { 
                LocalizationKey = SendNativeTokenLocalizer.Keys.Step3Title,
                LocalizationComponentType = typeof(SendNativeTokenViewModel),
                Label = "Transaction Status" // Fallback
            }
        };
        
        ViewModel.OnTransactionSent = (txHash) =>
        {
            if (OnTransactionSent.HasDelegate)
                _ = OnTransactionSent.InvokeAsync();
        };
        
        ViewModel.OnExit = () =>
        {
            if (OnCancel.HasDelegate)
                _ = OnCancel.InvokeAsync();
        };
        
        // Initialize the ViewModel with wallet data
        await ViewModel.InitializeAsync();

        // Notify parent that component is ready to receive navigation parameters
        OnReady?.Invoke(this);

        Trace("TokenTransfer OnInitializedAsync completed");

        StateHasChanged();
    }
    
    private async Task HandleCancel()
    {
        Trace("TokenTransfer HandleCancel invoked");
        if (OnCancel.HasDelegate)
            await OnCancel.InvokeAsync();
    }
    
    private async Task HandleBack()
    {
        Trace($"TokenTransfer HandleBack invoked (step {ViewModel.CurrentStep})");
        ViewModel.PreviousStepCommand.Execute(null);
        StateHasChanged();
    }
    
    private async Task HandleContinue()
    {
        Trace($"TokenTransfer HandleContinue invoked (step {ViewModel.CurrentStep})");
        // Clear any previous errors
        ViewModel.ErrorMessage = null;
        
        await ViewModel.NextStepCommand.ExecuteAsync(null);
        
        // Force UI update to show any validation errors
        StateHasChanged();
    }
    
    private async Task HandleSendTransaction()
    {
        Trace("TokenTransfer HandleSendTransaction invoked");
        await ViewModel.SendTransactionCommand.ExecuteAsync(null);
        Trace("TokenTransfer HandleSendTransaction completed");
        StateHasChanged();
    }
    
    private async Task HandleNewTransaction()
    {
        ViewModel.ResetCommand.Execute(null);
        await ViewModel.InitializeAsync();
        StateHasChanged();
    }
    
    private async Task HandleTransactionExit()
    {
        // User wants to exit after viewing transaction status
        if (OnCancel.HasDelegate)
            await OnCancel.InvokeAsync();
    }
    
    private void OnLanguageChanged(string languageCode)
    {
        InvokeAsync(StateHasChanged);
    }
    
    private void OnTransferModelPropertyChanged(object? sender, System.ComponentModel.PropertyChangedEventArgs e)
    {
        // Update UI when IsValid changes
        if (e.PropertyName == nameof(ViewModel.NativeTransfer.IsValid))
        {
            InvokeAsync(StateHasChanged);
        }
    }

    private async Task OpenExplorer(string? url)
    {
        if (!string.IsNullOrEmpty(url))
        {
            await JSRuntime.InvokeVoidAsync("open", url, "_blank");
        }
    }

    private async Task SetSubView(TransferSubView subView)
    {
        _currentSubView = subView;

        if (subView == TransferSubView.TokenPicker)
        {
            await ViewModel.RefreshKnownTokenBalancesCommand.ExecuteAsync(null);
        }

        StateHasChanged();
    }

    private async Task HandleTokenSearch(string searchText)
    {
        await ViewModel.SearchTokensCommand.ExecuteAsync(searchText);
    }

    private async Task HandleChainSelected(ChainFeature chain)
    {
        ViewModel.SelectedChain = chain;
        _currentSubView = TransferSubView.None;
        StateHasChanged();
    }

    private async Task HandleTokenSelected(AccountToken token)
    {
        await ViewModel.SelectTokenCommand.ExecuteAsync(token);
        _currentSubView = TransferSubView.None;
        StateHasChanged();
    }

    private void HandleContactSelected(Contact contact)
    {
        ViewModel.NativeTransfer.RecipientAddress = contact.Address;
        _currentSubView = TransferSubView.None;
        StateHasChanged();
    }

    private void HandleAccountSelected(IWalletAccount account)
    {
        ViewModel.SelectedAccount = account;
        _currentSubView = TransferSubView.None;
        StateHasChanged();
    }

    private async Task HandleTokenAdded()
    {
        await ViewModel.RefreshKnownTokenBalancesCommand.ExecuteAsync(null);
        _currentSubView = TransferSubView.None;
        StateHasChanged();
    }

    private async Task HandleGetBalance(AccountToken token)
    {
        await ViewModel.GetTokenBalanceCommand.ExecuteAsync(token);
        StateHasChanged();
    }
    
    public void Dispose()
    {
        LocalizationService.LanguageChanged -= OnLanguageChanged;
        
        if (ViewModel?.NativeTransfer != null)
        {
            ViewModel.NativeTransfer.PropertyChanged -= OnTransferModelPropertyChanged;
        }
    }

    private void Trace(string message)
    {
        WalletDiagnosticsLogger.Log("TokenTransfer", message);
    }

    public async Task NavigateWithParametersAsync(Dictionary<string, object> parameters)
    {
        Trace($"NavigateWithParametersAsync called with {parameters.Count} parameters");

        string? tokenContract = null;
        string? tokenSymbol = null;
        long? chainId = null;
        string? accountAddress = null;

        if (parameters.TryGetValue("TokenContract", out var contractObj))
            tokenContract = contractObj as string;

        if (parameters.TryGetValue("TokenSymbol", out var symbolObj))
            tokenSymbol = symbolObj as string;

        if (parameters.TryGetValue("ChainId", out var chainIdObj))
        {
            if (chainIdObj is long cid)
                chainId = cid;
            else if (chainIdObj is int intCid)
                chainId = intCid;
        }

        if (parameters.TryGetValue("AccountAddress", out var accountObj))
            accountAddress = accountObj as string;

        Trace($"Parsed: chain={chainId}, symbol={tokenSymbol}, contract={tokenContract}");

        // Apply pre-selection to the ViewModel
        await ViewModel.ApplyPreSelectionAsync(accountAddress, chainId, tokenContract, tokenSymbol);

        await InvokeAsync(StateHasChanged);
    }
}
